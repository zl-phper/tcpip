参考文章

- https://mp.weixin.qq.com/s/Pf0ZFGd2JyXAR0mjyGMtGg
- https://www.cnblogs.com/duan2/p/9180861.html 
- https://baijiahao.baidu.com/s?id=1664395039305097355&wfr=spider&for=pc
- https://blog.csdn.net/zgege/article/details/80445295
- https://www.jianshu.com/p/62940de97ca5



### 可靠的协议
为了实现可靠性传输，需要考虑很多事情，例如数据的破坏、丢包、重复以及分片顺序混乱等问题。 

那么，TCP 是通过序列号、确认应答、重发控制、连接管理以及窗口控制等机制实现可靠性传输的。

#### 重传机制

tcp中当发送端的数据传到接收主机的时候，接收端会主机会返回一个确认收到的消息，表示当前数据已经收到。

tcp 数据包中的字节号并不是已报文段来进行编号的而是将连接周期内的所有数据当做一个字节流，序列号就是字节流里面每一个字节的编号。序列号的初始值并不是0，而是在连接建立时候的生成的随机数，后面的序列号就是每个字节编号+1。如下图所示 就是一个正常的数据传输过程。

![image](https://pics1.baidu.com/feed/cf1b9d16fdfaaf51ae3e00197a371de8f11f7a25.jpeg?token=01dc64baee66f6036bc45ed81b6872d0)

但是在复杂的网络环境中，并不是所有的数据传输都能像上图那么顺利，如果有丢包的情况那么tcp会怎么做？

tcp 针对丢包的情况会有重传机制来解决

- 超时重传
- 快速重传
- SACK
- D-SACK
##### 超时重传
重传机制的其中一个方式就是设置一个超时时间，当请求方在超时时间后没有收到响应发送方就会去重新发送数据。

###### RTT
 RTT 也就是数据从网络一端到另一端的时间
###### RTO
RTO（Retransmission Timeout 超时重传时间） 也就是我们设置超时的时间，但是这个时间我们想象一下，如果设置的太大或者太小会发生什么事情
- 当RTO 设置的较大的时候，这时候如果发生了丢包那么发送方会包已经丢了老半天才去发，那么性能肯定就会变差。
- 当RTO 设置的较小的时候，这时候会导致数据包可能并没丢失就去重发数据，网络会拥堵，后面会又更多的重发，更多的重发雪崩效应。

是不是觉得我们只需要把RTO 设置为略大于RTT 的时间那么这样性能就能最高，其实并不是这样的，因为网络情况比较复杂，RTT 的值也是动态变化的，所以我们的RTO 也是动态的计算的，具体计算方法 [点我](https://www.cnblogs.com/lshs/p/6038541.html) 如果发生了超时重传 那么tcp 的策略就会把超时时间加倍，那么这样整个超时时间就会变得很长，那是不是有更好的重传机制

##### 快速重传 
tcp 还有一种重传机制叫快速重传，他不是依赖于超时时间，而是依赖于数据

![image](https://pics0.baidu.com/feed/359b033b5bb5c9eaf293c78c235a3f063bf3b3ec.jpeg?token=937d899f2dd68f43cd806eb6c908fae1)

图中我们一共发送了5份数据，每一次的seq 都应该能收到接收方的 ack = seq+1，但是上图中 第二次请求可能会发生丢包或者超时，但是第三次请求的包已经到了服务端ACK 还是回2 （由于TCP采用的是累计确认机制，即当接收端收到比期望序号大的报文段时，便会重复发送最近一次确认的报文段的确认信号，我们称之为冗余ACK（duplicate ACK）），协议规定当收到三个重复的ack时候，会再RTO的时间之内重新发送丢失的报文。 为什么是三次？ 参考文章在实际抓包中，大多数的丢包都会在大于3次冗余ACK后发生。所以规定为三次。

快速重传的机制可以解决超时时间的问题，但是其实还依然面临着一个别的问题，就是重传的时候 发送方并知道重传的时候是发送哪个包，就像上面的图，发送方并不知道是seq2 丢了还是seq3 |4|5 丢了。为了解决不知道该重传哪些报文，于是就有了SACK方法

##### SACK
 其实这个也很好理解，上面不是说了我们不知道哪些报文丢了么，我们知道报文其实就是一段字节流，并且每个字节都是有编号的，我们只需要响应ack的时候告诉我哪段就行了，如下图
 
 ![image](https://pics4.baidu.com/feed/1e30e924b899a901aef1d2c3ebf6837d0008f5ee.jpeg?token=a2a992442a19c5c635945ab4f7eea02a)
 我们就可以知道是200-299 这段数据丢了那么发送方只需要重发 第二次请求就可以了。
 
 ##### Duplicate SACK
 
 这个作用数用来告诉发送方哪些数据被重复的发送了，下面举个例子。
 
  ![image](https://pics4.baidu.com/feed/2cf5e0fe9925bc3128f19364a8bc04b7ca13700c.jpeg?token=70e97173300b1752392fb2b46294726a)
  ACK丢包
  - 接收方两个ack都丢失了，所以根据超时重发会重发第一个数据包 3000 - 3499
  - 于是接收方发现数据是重复收到的，于是回了一个 SACK = 3000~3500，告诉发送方 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 D-SACK。
  
  ### 滑动窗口 
    
